---
title: "Aula Pr√°tica: Coleta e An√°lise de Dados sobre Homic√≠dio Qualificado"
author:
- Jos√© de Jesus Filho e Alexandre Nicolella
format: html
---



## Introdu√ß√£o √† Aula Pr√°tica: Coleta de Dados no DataJud

Nesta aula pr√°tica, vamos aprender como coletar dados processuais utilizando a Base Nacional de Dados do Poder Judici√°rio (**DataJud**), mantida pelo Conselho Nacional de Justi√ßa (CNJ). O DataJud √© o sistema respons√°vel pelo armazenamento centralizado de dados e metadados de todos os processos judiciais brasileiros, f√≠sicos ou eletr√¥nicos, e ser√° a base que utilizaremos ao longo do curso.

##  Acesso ao DataJud

O DataJud pode ser acessado diretamente no site do CNJ üîó:

[https://www.cnj.jus.br/sistemas/datajud/](https://www.cnj.jus.br/sistemas/datajud/)

A plataforma fornece dados atualizados para diversos os ramos da Justi√ßa brasileira, agrupados e padronizados para permitir an√°lises estat√≠sticas e jurim√©tricas.

##  Autentica√ß√£o e Chave P√∫blica

Para acessar os dados via API, utilizaremos a **API P√∫blica** do DataJud, documentada em:

[https://datajud-wiki.cnj.jus.br/api-publica/](https://datajud-wiki.cnj.jus.br/api-publica/)

A autentica√ß√£o √© feita por meio de uma chave p√∫blica, disponibilizada pelo DPJ/CNJ. A chave  üîë pode ser obtida no seguinte endere√ßo:

[https://datajud-wiki.cnj.jus.br/api-publica/acesso](https://datajud-wiki.cnj.jus.br/api-publica/acesso)

Essa chave ser√° utilizada diretamente no c√≥digo em R (ou Python), permitindo realizar consultas autenticadas aos dados processuais.

##  Endpoints, Rotas e Sele√ß√£o de Tribunais

Para realizar nossas consultas, precisamos escolher os endpoints dispon√≠veis, indicando o tribunal desejado. Os endpoints est√£o detalhados em:

[https://datajud-wiki.cnj.jus.br/api-publica/endpoints](https://datajud-wiki.cnj.jus.br/api-publica/endpoints)

√â poss√≠vel consultar processos de de diversos ramos da Justi√ßa brasileira:

- **Tribunais Superiores**
- **Justi√ßa Federal**
- **Justi√ßa Estadual**
- **Justi√ßa do Trabalho**
- **Justi√ßa Eleitoral**
- **Justi√ßa Militar**

No nosso estudo, utilizaremos os dados do **Tribunal de Justi√ßa do Tocantins (TJTO)**.


##  Tipos de Consultas Poss√≠veis

A API permite diferentes modalidades de consulta üîç, como:

- Pesquisa por n√∫mero do processo
- Pesquisa paginada
- Pesquisa por classe
- Pesquisa por assunto
- ...

O DataJud tamb√©m disponibiliza exemplos de c√≥digo em Python e R, acess√≠veis na aba de exemplos:

[https://datajud-wiki.cnj.jus.br/api-publica/exemplos/](https://datajud-wiki.cnj.jus.br/api-publica/exemplos/)


##  Gloss√°rio de Vari√°veis

O DataJud define nomes espec√≠ficos para cada uma das vari√°veis retornadas pela API. O significado de cada termo pode ser consultado no gloss√°rio oficial:

[https://datajud-wiki.cnj.jus.br/api-publica/glossario](https://datajud-wiki.cnj.jus.br/api-publica/glossario)

Esse gloss√°rio √© essencial para interpretar corretamente os dados coletados.


## Sele√ß√£o do Assunto de Interesse

Em geral, ao iniciar uma pesquisa emp√≠rica, precisamos definir o assunto processual a ser analisado. Para isso, utilizamos o Sistema de Gest√£o de Tabelas Processuais Unificadas:

[https://www.cnj.jus.br/sgt/consulta_publica_assuntos.php](https://www.cnj.jus.br/sgt/consulta_publica_assuntos.php)

No nosso caso, o foco inicial seria **Direito Penal/Crimes Contra a Vida**, que inclui subcategorias como:

- **10915 ‚Äî Aborto**
- **12091 ‚Äî Feminic√≠dio**
- **12130 ‚Äî Homic√≠dio Agravado pela Pr√°tica de Exterm√≠nio de Seres Humanos**
- **3371 ‚Äî Homic√≠dio Privilegiado**
- **3372 ‚Äî Homic√≠dio Qualificado**
- **15177 ‚Äî Homic√≠dio Qualificado Contra Menor de 14 Anos (Lei Henry Borel)**
- **3370 ‚Äî Homic√≠dio Simples**
- **3373 ‚Äî Induzimento, Instiga√ß√£o ou Aux√≠lio a Suic√≠dio**
- **3375 ‚Äî Infantic√≠dio**

Poder√≠amos escolher todas ou algumas dessas categorias para nossa an√°lise.

## Escolha Alternativa: Pesquisa por Classe

Nesta aula, por√©m, seguiremos um caminho alternativo: em vez de selecionar um assunto espec√≠fico, trabalharemos com a **classe processual**.

Selecionamos o seguinte ramo:

**Processo Criminal ‚Üí Procedimento Comum ‚Üí A√ß√£o Penal de Compet√™ncia do J√∫ri**

**C√≥digo: 282**

Essa classe captura processos de crimes dolosos contra a vida julgados pelo Tribunal do J√∫ri, alinhados ao nosso objetivo anal√≠tico. Entretanto, muitos dos assuntos acima listados estar√£o presentes. Al√°m disso,  limitamos os nossos processos √† **Inst√¢ncia de 1¬∫ Grau (G1)**.


## Fase Muito Importante

A etapa que descrevemos at√© aqui √© fundamental em qualquer pesquisa emp√≠rica que utilize o DataJud ou outras bases de dados judiciais. As **escolhas feitas nesta fase**, como a defini√ß√£o do assunto, da classe processual e dos crit√©rios de filtragem, **influenciam diretamente o desenho amostral** que construiremos.

Uma **boa sele√ß√£o inicial** garante **maior precis√£o, consist√™ncia e relev√¢ncia dos resultados**. Por isso, √© essencial conduzir essa etapa com aten√ß√£o, calma e organiza√ß√£o. Quanto mais cuidadosa for a defini√ß√£o desses par√¢metros, melhor ser√° a qualidade da extra√ß√£o dos dados e, consequentemente, das an√°lises que realizaremos nas pr√≥ximas fases do curso.

## Colocando a M√£o na Massa: Coleta de Dados no DataJud

### Extra√≠ndo os Dados Processuais

O c√≥digo abaixo extrair√° os dados da **classe 282 do grau G1** do **Tribunal de Justi√ßa do Tocantins** e salvar√° todas essas informa√ß√µes em um dataframe chamado *juri.json*.


```{r eval = FALSE, message=FALSE, warning=FALSE}
# Bibloitecas Necess√°rias
library(tidyverse)
library(httr)
library(jsonlite)

# Definindo a Chave de Acesso
headers = c(
  'Authorization' = 'APIKey cDZHYzlZa0JadVREZDJCendQbXY6SkJlTzNjLV9TRENyQk1RdnFKZGRQdw==',
  'Content-Type' = 'application/json'
)

# Extraindo os dados do DataJud
## Classe 282 e grau G1 (1¬∫ Grau)
body = '{
  "size": 8930,
  "query": {
        "bool": {
            "must": [
                {"match": {"classe.codigo": 282}},
                {"match": {"grau": "G1"}}

            ]
        }
   }
}'

## Do Tribunal de Justi√ßa do Tocantins
POST(url = "https://api-publica.datajud.cnj.jus.br/api_publica_tjto/_search", body = body, add_headers(headers),
write_disk("juri.json"))

## Importanto o dado
juri <- fromJSON("juri.json")
save(juri, file = "juri.rds")
```



Agora vamos analisar a **estrutura do arquivo *juri.json*** para identificar onde cada informa√ß√£o relevante est√° **localizada**. Esse mapeamento √© essencial porque nos permite compreender exatamente como os **dados est√£o organizados** e, assim, definir qual tipo de **extra√ß√£o precisamos realizar** para trabalhar com informa√ß√µes de movimenta√ß√£o, √≥rg√£os julgadores, assuntos e outras caracter√≠sticas presentes no arquivo.

```{r eval = TRUE, message=FALSE, warning=FALSE}
#| results: "hide"

# Pacotes Necess√°rios
library(tidyverse)
library(httr)
library(jsonlite)

## Importanto o dado
load("juri.rds")

# 1. Verifica a classe do objeto (ex.: list, data.frame)
class(juri)  

# 2. ver nomes/elementos de topo
names(juri)          # se for lista ou data.frame, mostra colunas/elementos
length(juri)         # n√∫mero de elementos/top-level items

# 3. Exibe a estrutura do objeto; max.level evita sa√≠da muito grande
str(juri, max.level = 4) 

# 4.Extrai os dados principais: hits -> hits -> _source - Aqui est√£o os dados de interesse
## Cada n√≠vel corresponde a um ramo interno do JSON
dados_basicos <- juri |>
  pluck("hits","hits","_source")
```

### Analisando as Informa√ß√µes Extra√≠das 

**√ìrg√£o Julgador dos Processos**

Vamos criar um banco que contenha o n√∫mero do processo e o √≥rg√£o julgador respons√°vel por cada caso. Em seguida, analisaremos a frequ√™ncia de processos por √≥rg√£o julgador, tanto considerando apenas processos √∫nicos quanto incluindo processos duplicados.


```{r eval = TRUE, message=FALSE, warning=FALSE}

# Pacote que padroniza os nomes das vari√°veis
library(janitor)
library(dplyr)
library(tidyr)

# Criar um dataframe com n√∫mero do processo e √≥rg√£o julgador
julgador <- dados_basicos  |> 
      select(processo = numeroProcesso, orgaoJulgador) |> # Fa√ßo a sele√ß√£o e renomeio a coluna
      unnest(orgaoJulgador) |>  # Como orgaoJulgador √© um dataframe, preciso "desempacotar" os dados
      janitor::clean_names()    # Deixo os nomes padronizados
nrow(julgador) # n√∫mero total de processos
```

Observa-se um **total de 8430 processos**, mas alguns podem estar **duplicados**. Vamos investigar essa quest√£o. Abaixo est√° o c√≥digo para identificar e analisar processos √∫nicos e duplicados.


```{r eval = TRUE, message=FALSE, warning=FALSE}
# Vamos verificar se existem processos duplicados. 
julgador_uni <- julgador %>% 
  distinct(processo, .keep_all = TRUE)
nrow(julgador_uni) # numero total de processos √∫nicos
nrow(julgador) - nrow(julgador_uni) # n√∫mero de processos duplicados

# Vamos analisar os processos duplicados 
julgador_dup <- julgador %>% 
  filter(duplicated(processo) | duplicated(processo, fromLast = TRUE)) 
## Esse comando pega todas as linhas ap√≥s a primeira ocorr√™ncia ou 
## Pega todas as linhas antes da √∫ltima ocorr√™ncia e verifica duplica√ß√£o

## Vamos ver quantos processos duplicados temos:
nrow(julgador_dup) # n√∫mero de processos duplicados
unique(julgador_dup$processo) |> length() # n√∫mero de processos √∫nicos que est√£o duplicados

```

O total de **processos √∫nicos** foi de **8.287**, e identificamos **144 processos duplicados**. Agora, vamos verificar se essas duplica√ß√µes ocorreram em raz√£o de alguma mudan√ßa de √≥rg√£o julgador. Para isso, vamos pivotar os dados e criar uma vari√°vel que indique se houve altera√ß√£o no √≥rg√£o julgador para cada processo duplicado.

```{r eval = TRUE, message=FALSE, warning=FALSE}
## Analisando se houve troca de orga√µ julgador e por isso √© duplicado
# 1. Criar ordem dentro de cada processo 1, para primeira vez e 2 para a segunda vez....
julgador_dup_ord <- julgador_dup %>%
  group_by(processo) %>%
  mutate(orgao_id = row_number()) %>% 
  ungroup()

# 2. Pivotar para formato wide, selciono e indico o nome que ser√° dado
julgador_wide <- julgador_dup_ord %>%
  select(processo, orgao_id, nome) %>%
  pivot_wider(
    names_from = orgao_id,
    values_from = nome,
    names_prefix = "julgador"
  )
# 3. Vari√°vel indicando mudan√ßa
julgador_wide <- julgador_wide %>%
  rowwise() %>%
  mutate(
    mudou_orgao = n_distinct(c_across(starts_with("julgador")), na.rm = TRUE) > 1
  ) %>%
  ungroup()
# - > pega todas as colunas cujo nome come√ßa com "julgador", transforma em vetores e verifica se √© distinto

julgador_wide %>% 
  count(mudou_orgao, sort = TRUE) %>% 
  mutate(
    mudou_orgao = ifelse(mudou_orgao, "Sim", "N√£o")
  ) %>% 
  knitr::kable(
    caption = "Frequ√™ncia de processos que mudaram de √≥rg√£o julgador"
  )
```


Observamos que **93 processos n√£o mudaram de √≥rg√£o julgador** e **51 passaram por altera√ß√£o**. Agora precisamos definir como trataremos esses casos: se consideraremos apenas o *√≥rg√£o julgador final* ou se adotaremos o *√≥rg√£o julgador inicial* como refer√™ncia. Mas ainda precisamos observar que h√° **93 processos** que aparecem duplicados, mesmo **sem mudan√ßa de √≥rg√£o julgador**. O que pode estar acontecendo nesses casos?


Vamos focar nos processos √∫nicos para analisar a frequ√™ncia de √≥rg√£os julgadores e descrever os resultados graficamente e em tabelas.

```{r eval = TRUE, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)
library(gt)

freq_j_u <- julgador_uni %>% 
  count(nome) %>% 
  arrange(desc(n)) %>% 
  mutate(perc = round(100 * n / sum(n), 1))

ggplot(freq_j_u, aes(x = reorder(nome, n), y = n)) +
  geom_col(fill = "#7185cc", color = "white", alpha = 0.7) +
  coord_flip() +
  labs(
    title = "Frequ√™ncia por √ìrg√£o Julgador (Processos √önicos)",
    x = "√ìrg√£o Julgador",
    y = "Frequ√™ncia"
  ) +
  theme_classic()+
  theme(
    axis.text.y = element_text(size = 4)   # tamanho da letra das categorias
  )


freq_j_u |> 
  gt() |>
  tab_header(
    title = "Frequ√™ncia por √ìrg√£o Julgador (Processos √önicos)"
  ) |>
  cols_label(
    nome = "√ìrg√£o Julgador",
    n = "Frequ√™ncia",
    perc = "Percentual"
  )
``` 

**Sistema dos Processos**

Aqui avaliamos se os processos pertencem ao sistema **sistema eletr√¥nico de processos judiciais** EPROC ou a outro sistema.

```{r eval = TRUE, message=FALSE, warning=FALSE}
sistema <- dados_basicos  |> 
      select(processo = numeroProcesso, sistema) |> 
      unnest(sistema) |>
      janitor::clean_names()

freq_sistema <- sistema %>% 
  count(nome) %>% 
  arrange(desc(n))

freq_sistema |> 
  gt() |>
  tab_header(
    title = "Frequ√™ncia por Sistema (Processos √önicos)"
  ) |>
  cols_label(
    nome = "Sistema",
    n = "Frequ√™ncia",
  )
```

Com base na tabela acima, podemos observar a distribui√ß√£o dos processos entre os sistemas Eletr√¥nico e F√≠sico. Observa-se a exist√™ncia somente de processos eletr√¥nicos, mas 4 foram declaros inv√°lidos e 2 OUtros. O que fazer com esses casos? Devemos exclu√≠-los da an√°lise ou mant√™-los? 


**Formato do Processo**

Aqui avaliamos se os processos s√£o do tipo **Eletr√¥nico** ou **F√≠sico**.

```{r eval = TRUE, message=FALSE, warning=FALSE}
formato <- dados_basicos  |> 
      select(processo = numeroProcesso, formato) |> 
      unnest(formato) |>
      janitor::clean_names()

freq_formato <- formato %>% 
  count(nome) %>% 
  arrange(desc(n))

freq_formato |> 
  gt() |>
  tab_header(
    title = "Frequ√™ncia por Formato (Processos √önicos)"
  ) |>
  cols_label(
    nome = "Formato",
    n = "Frequ√™ncia",
  )
```

Observa-se que 100% dos processos est√£o no formato Eletr√¥nico. Dessa forma, n√£o h√° necessidade de excluir nenhum processo com base nesse crit√©rio.


**Classe Processual** 

Como fizemos nossa busca por classe processual, 282, dever√≠amos ter somente essa classe. Vamos verificar se h√° outras classes presentes nos dados.

```{r eval = TRUE, message=FALSE, warning=FALSE}

classe <- dados_basicos  |> 
      select(processo = numeroProcesso, classe) |> 
      unnest(classe) |>
      janitor::clean_names()

freq_classe <- classe %>% 
  count(nome) %>% 
  arrange(desc(n))

freq_classe |> 
  gt() |>
  tab_header(
    title = "Frequ√™ncia por Classe (Processos √önicos)"
  ) |>
  cols_label(
    nome = "Classe",
    n = "Frequ√™ncia",
  )
```

Conforme esperado pela nossa consulta inicial, todos os processos pertencem √† classe **A√ß√£o Penal de Compet√™ncia do J√∫ri (282)**. Portanto, n√£o h√° necessidade de excluir nenhum processo com base nesse crit√©rio.



**Assuntos Processuais**

Vamos extrair e analisar os assuntos processuais associados a cada processo. Vamos fazer a extra√ß√£o e veja que o resultado √© uma coluna com processo e a outra com o assunto. Se tivermos mais assuntos por processo, esse ser√° duplicado. 
```{r eval = TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(purrr)
library(janitor)
library(ggplot2)
library(gt)

 # manter s√≥ linhas em que 'assuntos' √© um data.frame
assuntos <- dados_basicos |> 
  filter(map_lgl(assuntos, is.data.frame)) |>
  select(processo = numeroProcesso, assuntos) |>
  unnest(assuntos) |>
  clean_names()

freq_assunto <- assuntos |> 
  count(nome) |> 
  arrange(desc(n)) |> 
  mutate(perc_assunto = round(100 * n / sum(n), 1)) |> 
  mutate(perc_processo = round(100 * n / 8288, 1))  # considerando processos √∫nicos


ggplot(freq_assunto, aes(x = reorder(nome, n), y = n)) +
  geom_col(fill = "#7185cc", color = "white", alpha = 0.7) +
  coord_flip() +
  labs(
    title = "Frequ√™ncia por Assunto (Processos √önicos)",
    x = "Assunto",
    y = "Frequ√™ncia"
  ) +
  theme_classic()+
  theme(
    axis.text.y = element_text(size = 4))   # tamanho da letra das categorias
    

freq_assunto |> 
  gt() |>
  tab_header(
    title = "Frequ√™ncia dos Assuntos"
  ) |>
  cols_label(
    nome = "Assunto",
    n = "Frequ√™ncia",
    perc_assunto = "% Assuntos",
    perc_processo = "% Processos"
  )

```

**Assuntos** tem um total de **11438 processos**, sendo que o n√∫mero de **processos √∫nicos √© 8288**. Isso indica que muitos processos t√™m mais de um assunto associado. Ent√£o a leitura da tabela acima deve considerar esses n√∫meros. Podemos dizer que **6007** processos tiveram **Homic√≠dio Qualificado** como assunto, **2762** tiveram **Crime Tentado**, e assim por diante. **Existe sobreposi√ß√£o** entre os dois assuntos. 

Fizemos duas colunas, uma com percentual com base no total de assuntos (11438), % Assuntos, e outra com base no total de processos √∫nicos (8288), % Processos. A segunda coluna √© mais interessante, pois indica a propor√ß√£o de processos que tiveram cada assunto.

Agora vamos olhar o assunto por processo, para ver quantos assuntos cada processo tem associado.


```{r eval = TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
assuntos_wide <- assuntos %>% 
  group_by(processo, nome) %>%   # garante uma linha por processo-assunto
  summarise(valor = 1, .groups = "drop") %>%
  pivot_wider(
    names_from = nome,
    values_from = valor,
    values_fill = list(valor = 0)   # preenche com 0 se n√£o ocorreu
  )

assuntos_wide %>% 
  slice_head(n = 10) %>% 
  select(1:8) %>%
  gt() %>% 
  tab_header(
    title = "Assuntos por Processo (Exemplo)"
  )
```

Agora cada linha √© um processo √∫nico com todos os assuntos listados. Tivemos um total de 8285, 3 processos a menos do que haviamos calculado anteriormente. Precisamos verificar o que aconteceu com esses 3 processos.

```{r eval = FALSE, message=FALSE, warning=FALSE}
# Instalando Pacotes necess√°rios
#install.packages("devtools") 
library(janitor)
devtools::install_github("courtsbr/JurisMiner")

movimento <- dados_basicos  |> 
      select(processo = numeroProcesso, movimentos) |>
      unnest(movimentos) |> 
      janitor::clean_names() |> 
      select(-complementos_tabelados) |> 
      mutate(data_hora = parse_datetime(data_hora))

movimento  <- movimento |> 
     arrange(processo, desc(data_hora)) |> 
     JurisMiner::tempo_movimentacao(data = data_hora)

```

